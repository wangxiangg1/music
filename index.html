<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>温暖简约音乐播放器</title>

    <!-- PWA 支持 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#d4a373">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Music">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="icon" type="image/png" href="icon.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap');

        /* 亮色模式 */
        :root {
            --bg-color: #f7f3f0;
            --panel-color: #ffffff;
            --accent-color: #d4a373;
            --text-main: #3d342f;
            --text-muted: #8c8279;
            --border-color: #e5e0db;
            --hover-color: #fcfaf8;
        }

        /* 深色模式 */
        :root.dark {
            --bg-color: #1a1a1a;
            --panel-color: #252525;
            --accent-color: #d4a373;
            --text-main: #e5e5e5;
            --text-muted: #999999;
            --border-color: #333333;
            --hover-color: #2a2a2a;
        }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
        }

        .soft-shadow {
            box-shadow: 0 10px 40px -10px rgba(130, 110, 90, 0.2);
        }

        :root.dark .soft-shadow {
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 10px;
        }

        input[type="range"] {
            appearance: none;
            -webkit-appearance: none;
            background: #e5e0db;
            border-radius: 10px;
            height: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .track-active {
            background-color: #fcfaf8;
            border-left: 3px solid var(--accent-color);
        }

        .loading-spinner {
            border: 2px solid #e5e0db;
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }

        /* 封面加载专用转圈 - 科技蓝主题 */
        .cover-spinner-wrapper {
            position: relative;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cover-spinner {
            position: absolute;
            border: 2px solid #dbeafe;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            width: 100%;
            height: 100%;
            animation: spin 0.8s linear infinite;
        }

        .cover-spinner-text {
            position: relative;
            z-index: 1;
            font-size: 9px;
            font-weight: 800;
            color: #3b82f6;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(61, 52, 47, 0.4);
            backdrop-filter: blur(4px);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        :root.dark .modal {
            background: rgba(0, 0, 0, 0.6);
        }

        .modal.active {
            display: flex;
        }

        .explorer-item:hover {
            background-color: var(--hover-color);
        }

        /* 播放模式按钮动画 */
        .mode-btn-active {
            color: var(--accent-color);
        }

        /* ========== 深色模式全局覆盖 ========== */
        :root.dark .bg-white {
            background-color: var(--panel-color) !important;
        }

        :root.dark .bg-stone-50,
        :root.dark .bg-stone-100 {
            background-color: #2a2a2a !important;
        }

        :root.dark .border-stone-50,
        :root.dark .border-stone-100 {
            border-color: var(--border-color) !important;
        }

        :root.dark .text-stone-500,
        :root.dark .text-stone-600 {
            color: #aaa !important;
        }

        :root.dark .text-stone-400 {
            color: #888 !important;
        }

        :root.dark .text-stone-300 {
            color: #666 !important;
        }

        :root.dark .text-stone-200 {
            color: #555 !important;
        }

        :root.dark .hover\:bg-stone-50:hover,
        :root.dark .hover\:bg-stone-100:hover,
        :root.dark .hover\:bg-stone-200:hover {
            background-color: #333 !important;
        }

        :root.dark .bg-\[\#ebe5df\] {
            background-color: #2a2a2a !important;
        }

        :root.dark input[type="range"] {
            background: #333;
        }

        :root.dark .track-active {
            background-color: #2a2a2a;
            border-left-color: var(--accent-color);
        }
    </style>
</head>

<body class="flex items-center justify-center p-6">

    <div class="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-12 gap-10">
        <!-- 左侧：播放控制 -->
        <div class="lg:col-span-7 flex flex-col justify-center space-y-8">
            <div class="space-y-2">
                <div class="flex items-center justify-between">
                    <div
                        class="flex items-center gap-2 text-sm font-medium tracking-widest text-orange-700/60 uppercase">
                        <span class="w-8 h-[1px] bg-orange-700/30"></span>
                        Now Playing
                    </div>
                    <!-- 深色模式切换按钮 -->
                    <button id="themeToggle"
                        class="p-2 rounded-xl hover:bg-stone-100 dark:hover:bg-stone-700 transition-colors"
                        title="切换深色模式">
                        <i data-lucide="sun" id="themeIconSun" class="w-5 h-5 text-amber-500 hidden"></i>
                        <i data-lucide="moon" id="themeIconMoon" class="w-5 h-5 text-stone-400"></i>
                    </button>
                </div>
                <h1 id="currentTitle" class="text-3xl md:text-5xl font-bold leading-tight truncate">享受音乐</h1>
                <p id="currentArtist" class="text-lg text-stone-400 italic font-light">选择你的音乐库</p>
            </div>

            <!-- 封面展示 -->
            <div class="relative">
                <div
                    class="w-full aspect-square md:aspect-video bg-[#ebe5df] rounded-[2.5rem] overflow-hidden soft-shadow flex items-center justify-center relative">
                    <div id="defaultCover" class="absolute inset-0 flex items-center justify-center">
                        <div
                            class="w-32 h-32 border-2 border-stone-200 rounded-full flex items-center justify-center animate-[spin_15s_linear_infinite]">
                            <div
                                class="w-24 h-24 border-2 border-stone-300 rounded-full flex items-center justify-center">
                                <div class="w-4 h-4 bg-stone-300 rounded-full"></div>
                            </div>
                        </div>
                    </div>
                    <img id="coverImg"
                        class="absolute inset-0 w-full h-full object-cover opacity-0 transition-opacity duration-700"
                        alt="Album Cover">
                    <canvas id="visualizer" class="absolute bottom-0 left-0 w-full h-1/2 pointer-events-none"></canvas>
                </div>
            </div>

            <!-- 控制面板 -->
            <div class="space-y-6 bg-white p-8 rounded-[2.5rem] soft-shadow">
                <div class="space-y-2">
                    <input type="range" id="progressBar" class="w-full cursor-pointer" value="0" step="0.1">
                    <div class="flex justify-between text-[10px] font-bold text-stone-400 tracking-tighter">
                        <span id="currentTime">00:00</span>
                        <span id="durationTime">00:00</span>
                    </div>
                </div>

                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-6">
                        <!-- 播放模式切换 -->
                        <button id="modeBtn" class="p-2 text-stone-300 hover:text-stone-800 transition" title="切换播放模式">
                            <i data-lucide="repeat" id="modeIcon" class="w-5 h-5"></i>
                        </button>

                        <div class="flex items-center gap-4">
                            <button id="prevBtn" class="hover:scale-110 transition text-stone-300 hover:text-stone-800">
                                <i data-lucide="skip-back" class="w-8 h-8"></i>
                            </button>
                            <button id="playBtn"
                                class="w-16 h-16 bg-stone-800 text-white rounded-full flex items-center justify-center hover:scale-105 transition shadow-xl">
                                <i data-lucide="play" id="playIcon" class="w-6 h-6 fill-current"></i>
                            </button>
                            <button id="nextBtn" class="hover:scale-110 transition text-stone-300 hover:text-stone-800">
                                <i data-lucide="skip-forward" class="w-8 h-8"></i>
                            </button>
                        </div>
                    </div>

                    <div class="flex items-center gap-3 w-32">
                        <i data-lucide="volume-1" class="w-4 h-4 text-stone-300"></i>
                        <input type="range" id="volumeBar" class="w-full" value="80" min="0" max="100">
                    </div>
                </div>
            </div>
        </div>

        <!-- 右侧：播放列表管理 -->
        <div class="lg:col-span-5 flex flex-col space-y-6">
            <div class="bg-white p-8 rounded-[2.5rem] soft-shadow flex flex-col h-[650px]">
                <div class="flex flex-col gap-4 mb-8">
                    <div class="flex items-center justify-between">
                        <h3 class="text-xl font-bold tracking-tight">播放列表</h3>
                        <div id="loadingStatus" class="hidden">
                            <div class="loading-spinner"></div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <label
                            class="flex-1 cursor-pointer text-center text-[10px] font-bold bg-stone-50 hover:bg-stone-100 border border-stone-100 px-3 py-3 rounded-2xl transition text-stone-600 uppercase tracking-widest">
                            本地文件
                            <input type="file" id="fileInput" class="hidden" multiple accept="audio/*">
                        </label>
                        <button id="webdavBtn"
                            class="flex-1 flex items-center justify-center gap-2 text-[10px] font-bold bg-amber-50 hover:bg-amber-100 border border-amber-100 px-3 py-3 rounded-2xl transition text-amber-700 uppercase tracking-widest">
                            <i data-lucide="server" class="w-3 h-3"></i> WebDAV 库
                        </button>
                    </div>
                </div>

                <div id="playlist" class="flex-1 overflow-y-auto custom-scrollbar space-y-1 pr-2">
                    <div class="flex flex-col items-center justify-center h-full text-stone-200">
                        <i data-lucide="library" class="w-12 h-12 mb-4 opacity-10"></i>
                        <p class="text-xs italic">尚未添加任何音乐</p>
                    </div>
                </div>

                <div class="mt-6 pt-6 border-t border-stone-50 flex justify-between items-center">
                    <div class="flex items-center gap-3">
                        <span id="trackCount" class="text-[10px] font-black text-stone-300 uppercase tracking-[0.2em]">0
                            Items</span>
                        <!-- 封面加载状态提示 - 转圈样式 -->
                        <div id="coverLoadStatus" class="hidden items-center gap-2">
                            <div class="cover-spinner-wrapper">
                                <div class="cover-spinner"></div>
                                <span id="coverSpinnerText" class="cover-spinner-text"></span>
                            </div>
                            <span id="coverLoadText" class="text-[10px] font-bold text-blue-500"></span>
                        </div>
                    </div>
                    <button id="clearBtn"
                        class="text-[10px] font-black text-red-200 hover:text-red-400 transition uppercase">Clear
                        All</button>
                </div>
            </div>
        </div>
    </div>

    <!-- WebDAV 模态框 (保持不变) -->
    <div id="webdavModal" class="modal">
        <div class="bg-white p-8 rounded-[2.5rem] w-full max-w-md soft-shadow mx-4">
            <h4 class="text-xl font-bold mb-6 flex items-center gap-2">
                <i data-lucide="cloud-lightning" class="w-5 h-5 text-amber-600"></i>
                WebDAV 连接
            </h4>
            <div class="space-y-4">
                <div>
                    <label
                        class="block text-[10px] font-bold text-stone-400 mb-1 uppercase tracking-widest">服务器地址</label>
                    <input type="text" id="davUrl" placeholder="https://example.com/dav"
                        class="w-full bg-stone-50 border-stone-100 border rounded-xl p-4 text-sm focus:ring-2 focus:ring-amber-200 outline-none transition-all">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label
                            class="block text-[10px] font-bold text-stone-400 mb-1 uppercase tracking-widest">用户名</label>
                        <input type="text" id="davUser"
                            class="w-full bg-stone-50 border-stone-100 border rounded-xl p-4 text-sm outline-none">
                    </div>
                    <div>
                        <label
                            class="block text-[10px] font-bold text-stone-400 mb-1 uppercase tracking-widest">密码</label>
                        <input type="password" id="davPass"
                            class="w-full bg-stone-50 border-stone-100 border rounded-xl p-4 text-sm outline-none">
                    </div>
                </div>
                <!-- 记住账户复选框 -->
                <div class="flex items-center gap-3 pt-2">
                    <input type="checkbox" id="rememberDav"
                        class="w-4 h-4 rounded border-stone-300 text-amber-600 focus:ring-amber-500">
                    <label for="rememberDav" class="text-xs text-stone-500">记住账户（保存到浏览器本地）</label>
                </div>
                <p class="text-[10px] text-stone-300 italic">提示：凭据仅存储在您的浏览器中，不会上传到服务器</p>
                <div class="flex gap-3 pt-4">
                    <button id="closeModal"
                        class="flex-1 p-4 rounded-2xl bg-stone-100 text-stone-500 font-bold text-sm hover:bg-stone-200 transition">取消</button>
                    <button id="connectDav"
                        class="flex-1 p-4 rounded-2xl bg-stone-800 text-white font-bold text-sm shadow-lg hover:bg-stone-700 transition">浏览文件</button>
                </div>
            </div>
        </div>
    </div>

    <!-- WebDAV 文件管理/选择模态框 -->
    <div id="explorerModal" class="modal">
        <div class="bg-white p-8 rounded-[2.5rem] w-full max-w-2xl soft-shadow mx-4 flex flex-col h-[80vh]">
            <div class="flex items-center justify-between mb-6">
                <h4 class="text-xl font-bold flex items-center gap-2">
                    <i data-lucide="folder-open" class="w-5 h-5 text-amber-600"></i>
                    资源管理器
                </h4>
                <button id="closeExplorer" class="text-stone-400 hover:text-stone-800 transition">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>

            <div id="explorerPath"
                class="bg-stone-50 p-3 rounded-xl mb-4 text-[10px] font-mono text-stone-400 truncate">/</div>
            <div id="explorerList" class="flex-1 overflow-y-auto custom-scrollbar border border-stone-50 rounded-2xl">
            </div>

            <div class="mt-6 pt-6 border-t border-stone-50 flex justify-end items-center gap-4">
                <p class="text-[10px] text-stone-400 font-bold uppercase mr-auto"><span id="selectedCount">0</span> 项待导入
                </p>
                <button id="importCurrentDir"
                    class="px-6 py-3 rounded-xl bg-stone-100 text-stone-600 font-bold text-sm hover:bg-stone-200 transition">导入本目录</button>
                <button id="importSelected"
                    class="px-8 py-3 rounded-xl bg-amber-600 text-white font-bold text-sm shadow-lg shadow-amber-100 hover:bg-amber-700 transition">导入已选</button>
            </div>
        </div>
    </div>

    <audio id="audioElement"></audio>

    <script>
        lucide.createIcons();

        // ========== IndexedDB 音频缓存系统 ==========
        const CACHE_DB_NAME = 'MusicPlayerCache';
        const CACHE_STORE_NAME = 'audioFiles';
        const CACHE_MAX_SIZE = 250 * 1024 * 1024; // 250MB
        let cacheDB = null;

        // 初始化 IndexedDB
        async function initCacheDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CACHE_DB_NAME, 1);

                request.onerror = () => {
                    console.error('无法打开缓存数据库');
                    resolve(null);
                };

                request.onsuccess = (event) => {
                    cacheDB = event.target.result;
                    console.log('缓存数据库已就绪');
                    resolve(cacheDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(CACHE_STORE_NAME)) {
                        const store = db.createObjectStore(CACHE_STORE_NAME, { keyPath: 'key' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };
            });
        }

        // 获取缓存的音频
        async function getCachedAudio(key) {
            if (!cacheDB) return null;

            return new Promise((resolve) => {
                try {
                    const transaction = cacheDB.transaction([CACHE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CACHE_STORE_NAME);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        if (request.result) {
                            console.log(`从缓存加载: ${key}`);
                            resolve(request.result.blob);
                        } else {
                            resolve(null);
                        }
                    };

                    request.onerror = () => resolve(null);
                } catch (e) {
                    resolve(null);
                }
            });
        }

        // 保存音频到缓存
        async function cacheAudio(key, blob) {
            if (!cacheDB) return;

            try {
                // 先检查总缓存大小
                await enforceСacheLimit(blob.size);

                const transaction = cacheDB.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);

                store.put({
                    key: key,
                    blob: blob,
                    size: blob.size,
                    timestamp: Date.now()
                });

                console.log(`已缓存: ${key} (${(blob.size / 1024 / 1024).toFixed(2)}MB)`);
            } catch (e) {
                console.error('缓存保存失败:', e);
            }
        }

        // 强制执行缓存大小限制
        async function enforceСacheLimit(newFileSize) {
            if (!cacheDB) return;

            return new Promise((resolve) => {
                const transaction = cacheDB.transaction([CACHE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const index = store.index('timestamp');

                let totalSize = 0;
                const itemsToDelete = [];

                // 遍历所有缓存项，按时间排序
                const request = index.openCursor();
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        totalSize += cursor.value.size || 0;
                        itemsToDelete.push({ key: cursor.value.key, size: cursor.value.size });
                        cursor.continue();
                    } else {
                        // 计算需要删除多少
                        let sizeToFree = (totalSize + newFileSize) - CACHE_MAX_SIZE;

                        if (sizeToFree > 0) {
                            console.log(`缓存超限，需要释放 ${(sizeToFree / 1024 / 1024).toFixed(2)}MB`);

                            // 删除最旧的文件直到腾出足够空间
                            for (const item of itemsToDelete) {
                                if (sizeToFree <= 0) break;
                                store.delete(item.key);
                                sizeToFree -= item.size;
                                console.log(`删除缓存: ${item.key}`);
                            }
                        }

                        resolve();
                    }
                };

                request.onerror = () => resolve();
            });
        }

        // 获取缓存统计
        async function getCacheStats() {
            if (!cacheDB) return { count: 0, size: 0 };

            return new Promise((resolve) => {
                const transaction = cacheDB.transaction([CACHE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CACHE_STORE_NAME);
                const request = store.getAll();

                request.onsuccess = () => {
                    const items = request.result || [];
                    const totalSize = items.reduce((sum, item) => sum + (item.size || 0), 0);
                    console.log(`缓存统计: ${items.length} 个文件, ${(totalSize / 1024 / 1024).toFixed(2)}MB / 250MB`);
                    resolve({ count: items.length, size: totalSize });
                };

                request.onerror = () => resolve({ count: 0, size: 0 });
            });
        }

        // 初始化缓存
        initCacheDB().then(() => getCacheStats());

        const state = {
            playlist: [],
            currentIndex: -1,
            isPlaying: false,
            // 播放模式: 'list' (列表循环), 'random' (随机), 'single' (单曲循环)
            playMode: 'list',
            audioContext: null,
            analyser: null,
            source: null,
            animationId: null,
            davConfig: { url: '', auth: '' },
            currentBrowsingUrl: '',
            explorerItems: [],
            selectedItems: [],
            // 播放历史（用于随机模式下的"上一首"）
            playHistory: [],
            playHistoryIndex: -1,
            // 可视化颜色（从封面提取）
            visualizerColors: {
                primary: { r: 212, g: 163, b: 115 },    // 默认琥琥色
                secondary: { r: 180, g: 120, b: 80 },   // 默认深色
                accent: { r: 235, g: 200, b: 160 }      // 默认高光色
            }
        };

        const elements = {
            fileInput: document.getElementById('fileInput'),
            webdavBtn: document.getElementById('webdavBtn'),
            webdavModal: document.getElementById('webdavModal'),
            closeModal: document.getElementById('closeModal'),
            connectDav: document.getElementById('connectDav'),
            explorerModal: document.getElementById('explorerModal'),
            closeExplorer: document.getElementById('closeExplorer'),
            explorerList: document.getElementById('explorerList'),
            explorerPath: document.getElementById('explorerPath'),
            importSelected: document.getElementById('importSelected'),
            importCurrentDir: document.getElementById('importCurrentDir'),
            selectedCount: document.getElementById('selectedCount'),
            playlist: document.getElementById('playlist'),
            audio: document.getElementById('audioElement'),
            playBtn: document.getElementById('playBtn'),
            playIcon: document.getElementById('playIcon'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            modeBtn: document.getElementById('modeBtn'),
            modeIcon: document.getElementById('modeIcon'),
            currentTitle: document.getElementById('currentTitle'),
            currentArtist: document.getElementById('currentArtist'),
            progressBar: document.getElementById('progressBar'),
            volumeBar: document.getElementById('volumeBar'),
            currentTimeText: document.getElementById('currentTime'),
            durationTimeText: document.getElementById('durationTime'),
            trackCount: document.getElementById('trackCount'),
            clearBtn: document.getElementById('clearBtn'),
            visualizer: document.getElementById('visualizer'),
            coverImg: document.getElementById('coverImg'),
            defaultCover: document.getElementById('defaultCover'),
            loadingStatus: document.getElementById('loadingStatus')
        };

        // --- 播放模式切换 ---
        const modes = [
            { id: 'list', icon: 'repeat', label: '列表循环' },
            { id: 'random', icon: 'shuffle', label: '随机播放' },
            { id: 'single', icon: 'repeat-1', label: '单曲循环' }
        ];

        elements.modeBtn.onclick = () => {
            const currentIdx = modes.findIndex(m => m.id === state.playMode);
            const nextIdx = (currentIdx + 1) % modes.length;
            state.playMode = modes[nextIdx].id;

            // 更新 UI - 先插入新的 i 标签，然后让 Lucide 转换，最后更新引用
            const iconContainer = elements.modeBtn;
            iconContainer.innerHTML = `<i data-lucide="${modes[nextIdx].icon}" id="modeIcon" class="w-5 h-5"></i>`;
            lucide.createIcons({ nodes: [iconContainer] }); // 只对这个容器内的图标进行转换
            elements.modeIcon = iconContainer.querySelector('svg') || iconContainer.querySelector('[data-lucide]');
            elements.modeBtn.title = modes[nextIdx].label;
            elements.modeBtn.classList.toggle('mode-btn-active', state.playMode !== 'list');
        };

        // --- 核心播放逻辑修复 ---
        function updatePlayIcon() {
            // 确保图标与状态同步 - 先插入新的 i 标签，然后让 Lucide 转换
            const iconName = state.isPlaying ? 'pause' : 'play';
            const iconContainer = elements.playBtn;
            // 保留按钮内容，只替换图标部分
            const currentIcon = iconContainer.querySelector('svg') || iconContainer.querySelector('[data-lucide]');
            if (currentIcon) {
                currentIcon.outerHTML = `<i data-lucide="${iconName}" id="playIcon" class="w-6 h-6 fill-current"></i>`;
            }
            lucide.createIcons({ nodes: [iconContainer] }); // 只对这个容器内的图标进行转换
            elements.playIcon = iconContainer.querySelector('svg') || iconContainer.querySelector('[data-lucide]');
        }

        async function playTrack(index, shouldAddToHistory = true) {
            if (index < 0 || index >= state.playlist.length) return;
            state.currentIndex = index;
            const track = state.playlist[index];

            // 添加到播放历史
            if (shouldAddToHistory) {
                addToHistory(index);
            }

            if (track.source === 'webdav' && !track.url) {
                elements.loadingStatus.classList.remove('hidden');
                try {
                    // 生成缓存键（使用URL作为唯一标识）
                    const cacheKey = track.fetchUrl;

                    // 先尝试从缓存加载
                    let blob = await getCachedAudio(cacheKey);

                    if (!blob) {
                        // 缓存未命中，从网络下载
                        console.log(`从网络下载: ${track.name}`);
                        const res = await fetch(track.fetchUrl, { headers: { 'Authorization': track.auth } });
                        blob = await res.blob();

                        // 存入缓存
                        await cacheAudio(cacheKey, blob);
                    }

                    track.url = URL.createObjectURL(blob);
                    const meta = await getMetadata(blob);
                    Object.assign(track, meta);
                } catch (e) {
                    console.error("加载失败", e);
                }
                elements.loadingStatus.classList.add('hidden');
            }

            elements.audio.src = track.url;
            elements.currentTitle.textContent = track.title || track.name.replace(/\.[^/.]+$/, "");
            elements.currentArtist.textContent = track.artist || (track.source === 'webdav' ? "WebDAV Library" : "本地文件");

            if (track.cover) {
                elements.coverImg.src = track.cover;
                elements.coverImg.classList.add('opacity-100');
                elements.defaultCover.classList.add('opacity-0');
                // 从封面提取颜色
                extractColorsFromImage(track.cover);
            } else {
                elements.coverImg.classList.remove('opacity-100');
                elements.defaultCover.classList.remove('opacity-0');
                // 重置为默认颜色
                state.visualizerColors = {
                    primary: { r: 212, g: 163, b: 115 },
                    secondary: { r: 180, g: 120, b: 80 },
                    accent: { r: 235, g: 200, b: 160 }
                };
            }

            renderPlaylist();

            // 播放音频并更新状态
            try {
                await elements.audio.play();
                state.isPlaying = true;
            } catch (err) {
                console.error("播放被拦截或失败:", err);
                state.isPlaying = false;
            }
            updatePlayIcon();
            setupVisualizer();

            // 更新媒体会话（锁屏控制）
            updateMediaSession(track);
        }

        // ========== 媒体会话 API（锁屏控制）==========
        function updateMediaSession(track) {
            if (!('mediaSession' in navigator)) return;

            const artwork = [];
            if (track.cover) {
                artwork.push({ src: track.cover, sizes: '512x512', type: 'image/jpeg' });
            }

            navigator.mediaSession.metadata = new MediaMetadata({
                title: track.title || track.name || '未知歌曲',
                artist: track.artist || '未知艺术家',
                album: 'Music Player',
                artwork: artwork
            });

            // 设置媒体会话操作处理器
            navigator.mediaSession.setActionHandler('play', () => {
                elements.audio.play();
                state.isPlaying = true;
                updatePlayIcon();
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                elements.audio.pause();
                state.isPlaying = false;
                updatePlayIcon();
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                prevTrack();
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                nextTrack();
            });

            navigator.mediaSession.setActionHandler('seekto', (details) => {
                if (details.seekTime) {
                    elements.audio.currentTime = details.seekTime;
                }
            });
        }

        elements.playBtn.onclick = () => {
            if (state.currentIndex === -1 && state.playlist.length > 0) {
                playTrack(0);
                return;
            }
            if (state.currentIndex === -1) return;

            if (state.isPlaying) {
                elements.audio.pause();
                state.isPlaying = false;
            } else {
                elements.audio.play();
                state.isPlaying = true;
            }
            updatePlayIcon();
        };

        // --- 智能切歌逻辑（支持播放历史）---
        function addToHistory(index) {
            // 如果是从历史中回退后又前进，截断后面的历史
            if (state.playHistoryIndex < state.playHistory.length - 1) {
                state.playHistory = state.playHistory.slice(0, state.playHistoryIndex + 1);
            }
            state.playHistory.push(index);
            state.playHistoryIndex = state.playHistory.length - 1;

            // 限制历史记录长度
            if (state.playHistory.length > 100) {
                state.playHistory.shift();
                state.playHistoryIndex--;
            }
        }

        function nextTrack() {
            if (state.playlist.length === 0) return;

            let nextIndex;

            // 检查是否可以从历史中前进
            if (state.playHistoryIndex < state.playHistory.length - 1) {
                state.playHistoryIndex++;
                nextIndex = state.playHistory[state.playHistoryIndex];
                playTrack(nextIndex, false); // false = 不添加到历史
                return;
            }

            if (state.playMode === 'random') {
                // 随机选择，但避免选到当前歌曲
                do {
                    nextIndex = Math.floor(Math.random() * state.playlist.length);
                } while (nextIndex === state.currentIndex && state.playlist.length > 1);
            } else if (state.playMode === 'single') {
                nextIndex = state.currentIndex;
            } else {
                // 列表循环
                nextIndex = (state.currentIndex + 1) % state.playlist.length;
            }

            playTrack(nextIndex, true); // true = 添加到历史
        }

        function prevTrack() {
            if (state.playlist.length === 0) return;

            // 随机模式下：从播放历史中回退
            if (state.playMode === 'random') {
                if (state.playHistoryIndex > 0) {
                    state.playHistoryIndex--;
                    const prevIndex = state.playHistory[state.playHistoryIndex];
                    playTrack(prevIndex, false); // false = 不添加到历史
                }
                return;
            }

            // 列表/单曲模式：正常上一首
            let prevIndex = state.currentIndex - 1;
            if (prevIndex < 0) prevIndex = state.playlist.length - 1;
            playTrack(prevIndex, true);
        }

        elements.nextBtn.onclick = nextTrack;
        elements.audio.onended = nextTrack;
        elements.prevBtn.onclick = prevTrack;

        // --- WebDAV & 其他逻辑 (保持不变但确保集成) ---

        // 打开 WebDAV 配置模态框
        elements.webdavBtn.onclick = () => {
            // 加载已保存的凭据
            const savedConfig = localStorage.getItem('webdav_config');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    document.getElementById('davUrl').value = config.url || '';
                    document.getElementById('davUser').value = config.user || '';
                    document.getElementById('davPass').value = config.pass || '';
                    document.getElementById('rememberDav').checked = true;
                } catch (e) {
                    console.error('加载配置失败:', e);
                }
            }
            elements.webdavModal.classList.add('active');
        };

        // 关闭 WebDAV 模态框
        elements.closeModal.onclick = () => {
            elements.webdavModal.classList.remove('active');
        };

        // 关闭资源管理器模态框
        elements.closeExplorer.onclick = () => {
            elements.explorerModal.classList.remove('active');
        };

        elements.connectDav.onclick = async () => {
            let url = document.getElementById('davUrl').value.trim();
            const user = document.getElementById('davUser').value.trim();
            const pass = document.getElementById('davPass').value.trim();
            const remember = document.getElementById('rememberDav').checked;

            if (!url) return;
            if (!url.startsWith('http')) url = 'https://' + url;
            if (!url.endsWith('/')) url += '/';

            // 保存或清除凭据
            if (remember) {
                localStorage.setItem('webdav_config', JSON.stringify({ url, user, pass }));
            } else {
                localStorage.removeItem('webdav_config');
            }

            state.davConfig.url = url;
            state.davConfig.auth = 'Basic ' + btoa(user + ':' + pass);
            elements.webdavModal.classList.remove('active');
            browseFolder(url);
        };

        // 支持的音频格式列表
        const SUPPORTED_AUDIO_FORMATS = [
            '.mp3', '.aac', '.m4a', '.wav', '.ogg', '.oga',
            '.flac', '.opus', '.webm', '.mp4', '.weba'
        ];

        function isSupportedAudio(fileName) {
            const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
            return SUPPORTED_AUDIO_FORMATS.includes(ext);
        }

        async function browseFolder(fullUrl) {
            elements.loadingStatus.classList.remove('hidden');
            try {
                const targetUrl = fullUrl.endsWith('/') ? fullUrl : fullUrl + '/';
                const response = await fetch(targetUrl, {
                    method: 'PROPFIND',
                    headers: { 'Authorization': state.davConfig.auth, 'Depth': '1' }
                });
                if (!response.ok) throw new Error('连接失败');
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const responses = Array.from(xml.getElementsByTagNameNS('*', 'response'));
                state.currentBrowsingUrl = targetUrl;
                const urlObj = new URL(targetUrl);
                elements.explorerPath.textContent = urlObj.pathname;
                const items = [];
                responses.forEach((res) => {
                    const hrefRaw = res.getElementsByTagNameNS('*', 'href')[0].textContent;
                    const absoluteHref = hrefRaw.startsWith('http') ? hrefRaw : new URL(hrefRaw, urlObj.origin).href;
                    if (absoluteHref === targetUrl || absoluteHref === targetUrl.slice(0, -1)) return;
                    const prop = res.getElementsByTagNameNS('*', 'prop')[0];
                    const resourcetype = prop.getElementsByTagNameNS('*', 'resourcetype')[0];
                    const isCollection = resourcetype && resourcetype.getElementsByTagNameNS('*', 'collection').length > 0;
                    const fileName = decodeURIComponent(absoluteHref.split('/').filter(p => p).pop() || '/');

                    // 只显示文件夹和支持的音频格式
                    if (isCollection || isSupportedAudio(fileName)) {
                        items.push({ name: fileName, href: absoluteHref, isFolder: isCollection, selected: false });
                    }
                });
                state.explorerItems = items;
                state.selectedItems = [];
                renderExplorer();
                elements.explorerModal.classList.add('active');
            } catch (e) { alert("无法浏览文件夹内容。"); } finally { elements.loadingStatus.classList.add('hidden'); }
        }

        function renderExplorer() {
            elements.explorerList.innerHTML = '';
            if (state.currentBrowsingUrl !== state.davConfig.url) {
                const upBtn = document.createElement('div');
                upBtn.className = 'explorer-item p-4 flex items-center gap-4 cursor-pointer text-stone-400 border-b border-stone-50';
                upBtn.innerHTML = `<i data-lucide="corner-left-up" class="w-4 h-4"></i> <span class="text-xs font-bold uppercase tracking-widest">返回上级目录</span>`;
                upBtn.onclick = () => browseFolder(new URL('../', state.currentBrowsingUrl).href);
                elements.explorerList.appendChild(upBtn);
            }
            state.explorerItems.forEach((item) => {
                const div = document.createElement('div');
                div.className = `explorer-item p-4 flex items-center gap-4 cursor-pointer border-b border-stone-50 transition-colors ${item.selected ? 'bg-amber-50' : ''}`;
                div.innerHTML = `
                    <div class="flex-shrink-0"><i data-lucide="${item.selected ? 'check-square' : (item.isFolder ? 'folder' : 'music')}" class="w-5 h-5 ${item.selected ? 'text-amber-600' : (item.isFolder ? 'text-amber-500' : 'text-stone-400')}"></i></div>
                    <div class="flex-1 min-w-0"><p class="text-sm font-medium truncate ${item.isFolder ? 'font-bold' : ''}">${item.name}</p></div>
                `;
                div.onclick = () => {
                    if (item.isFolder) browseFolder(item.href);
                    else { item.selected = !item.selected; renderExplorer(); updateSelectedCount(); }
                };
                elements.explorerList.appendChild(div);
            });
            lucide.createIcons();
            updateSelectedCount();
        }

        function updateSelectedCount() {
            state.selectedItems = state.explorerItems.filter(i => i.selected);
            elements.selectedCount.textContent = state.selectedItems.length;
        }

        elements.importSelected.onclick = () => {
            const tracks = state.selectedItems.map(item => ({ name: item.name, fetchUrl: item.href, auth: state.davConfig.auth, source: 'webdav' }));
            if (tracks.length === 0) return;
            state.playlist = [...state.playlist, ...tracks];
            renderPlaylist();
            elements.explorerModal.classList.remove('active');
        };

        elements.importCurrentDir.onclick = () => {
            const audioTracks = state.explorerItems.filter(item => !item.isFolder).map(item => ({ name: item.name, fetchUrl: item.href, auth: state.davConfig.auth, source: 'webdav' }));
            if (audioTracks.length === 0) return;
            state.playlist = [...state.playlist, ...audioTracks];
            renderPlaylist();
            elements.explorerModal.classList.remove('active');
        };

        async function getMetadata(file) {
            return new Promise((resolve) => {
                jsmediatags.read(file, {
                    onSuccess: (tag) => {
                        const { title, artist, picture } = tag.tags;
                        let cover = null;
                        if (picture) {
                            const { data, format } = picture;
                            let base = "";
                            for (let i = 0; i < data.length; i++) base += String.fromCharCode(data[i]);
                            cover = `data:${format};base64,${window.btoa(base)}`;
                        }
                        resolve({ title, artist, cover });
                    },
                    onError: () => resolve({ title: null, artist: null, cover: null })
                });
            });
        }

        function renderPlaylist() {
            if (state.playlist.length === 0) {
                elements.playlist.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-stone-200"><i data-lucide="music-2" class="w-12 h-12 mb-2 opacity-10"></i><p class="text-[10px] font-bold uppercase tracking-widest">Empty</p></div>`;
                lucide.createIcons();
                return;
            }
            elements.playlist.innerHTML = '';
            elements.trackCount.textContent = `${state.playlist.length} Tracks`;
            state.playlist.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = `group p-4 rounded-3xl cursor-pointer transition flex items-center gap-4 hover:bg-stone-50 ${index === state.currentIndex ? 'track-active' : ''}`;
                item.dataset.index = index; // 添加索引用于懒加载
                item.innerHTML = `
                    <div class="cover-container w-10 h-10 rounded-xl overflow-hidden bg-stone-100 flex-shrink-0 relative">
                        ${track.cover ? `<img src="${track.cover}" class="w-full h-full object-cover">` : `<div class="w-full h-full flex items-center justify-center text-stone-300"><i data-lucide="music" class="w-4 h-4"></i></div>`}
                        ${track.source === 'webdav' ? `<div class="absolute bottom-0 right-0 bg-amber-600 p-0.5 rounded-tl-md"><i data-lucide="server" class="w-2 h-2 text-white"></i></div>` : ''}
                    </div>
                    <div class="flex-1 min-w-0">
                        <p class="text-sm font-bold truncate ${index === state.currentIndex ? 'text-stone-800' : 'text-stone-500'}">${track.title || track.name}</p>
                        <p class="text-[9px] text-stone-400 font-bold uppercase tracking-wider">${track.artist || 'Local Collection'}</p>
                    </div>
                `;
                item.onclick = () => playTrack(index);
                elements.playlist.appendChild(item);
            });
            lucide.createIcons();

            // 设置封面懒加载（仅对WebDAV曲目）
            setupCoverLazyLoad();
        }

        // 封面懒加载相关变量
        let coverLoadTimer = null;
        let coverObserver = null;
        let countdownTimer = null;
        let countdownValue = 5;

        // UI状态更新函数
        function updateCoverLoadStatus(text, spinnerText = '', show = true) {
            const statusEl = document.getElementById('coverLoadStatus');
            const textEl = document.getElementById('coverLoadText');
            const spinnerTextEl = document.getElementById('coverSpinnerText');

            if (statusEl && textEl) {
                if (show) {
                    statusEl.classList.remove('hidden');
                    statusEl.classList.add('flex');
                    textEl.textContent = text;
                    if (spinnerTextEl) spinnerTextEl.textContent = spinnerText;
                } else {
                    statusEl.classList.add('hidden');
                    statusEl.classList.remove('flex');
                }
            }
        }

        // 开始倒计时显示
        function startCountdown(visibleIndices) {
            // 检查是否有需要加载的封面
            const needLoad = Array.from(visibleIndices).some(index => {
                const track = state.playlist[index];
                return track && track.source === 'webdav' && !track.cover && !track.coverLoading && !track.url;
            });

            if (!needLoad) {
                updateCoverLoadStatus('', '', false);
                return;
            }

            countdownValue = 5;
            updateCoverLoadStatus('加载封面', countdownValue);

            // 清除之前的倒计时
            if (countdownTimer) clearInterval(countdownTimer);

            countdownTimer = setInterval(() => {
                countdownValue--;
                if (countdownValue > 0) {
                    updateCoverLoadStatus('加载封面', countdownValue);
                } else {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
            }, 1000);
        }

        // 停止倒计时
        function stopCountdown() {
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            updateCoverLoadStatus('', '', false);
        }

        function setupCoverLazyLoad() {
            // 清除之前的定时器和观察器
            if (coverLoadTimer) clearTimeout(coverLoadTimer);
            if (coverObserver) coverObserver.disconnect();
            stopCountdown();

            // 获取所有需要加载封面的WebDAV曲目元素
            const playlistItems = elements.playlist.querySelectorAll('[data-index]');
            if (playlistItems.length === 0) return;

            // 记录可视区域内的元素索引
            const visibleIndices = new Set();

            // 创建IntersectionObserver检测可视区域
            coverObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const index = parseInt(entry.target.dataset.index);
                    if (entry.isIntersecting) {
                        visibleIndices.add(index);
                    } else {
                        visibleIndices.delete(index);
                    }
                });

                // 重置定时器（用户滚动时重新计时）
                if (coverLoadTimer) clearTimeout(coverLoadTimer);
                stopCountdown();
                startCountdown(visibleIndices);

                coverLoadTimer = setTimeout(() => {
                    loadVisibleCovers(visibleIndices);
                }, 5000); // 5秒后加载
            }, {
                root: elements.playlist,
                threshold: 0.1
            });

            // 观察所有曲目元素
            playlistItems.forEach(item => {
                coverObserver.observe(item);
            });

            // 监听滚动事件重置计时器
            elements.playlist.onscroll = () => {
                if (coverLoadTimer) clearTimeout(coverLoadTimer);
                stopCountdown();
                startCountdown(visibleIndices);

                coverLoadTimer = setTimeout(() => {
                    loadVisibleCovers(visibleIndices);
                }, 5000);
            };
        }

        // 加载可视区域内的封面
        // 并发控制参数
        const CONCURRENT_COVER_LOADS = 3; // 最多同时加载3个封面

        async function loadVisibleCovers(visibleIndices) {
            stopCountdown(); // 停止倒计时

            const indicesToLoad = Array.from(visibleIndices).filter(index => {
                const track = state.playlist[index];
                return track && track.source === 'webdav' && !track.cover && !track.coverLoading;
            });

            if (indicesToLoad.length === 0) {
                updateCoverLoadStatus('', '', false);
                return;
            }

            console.log(`开始加载 ${indicesToLoad.length} 个可视封面（并发数: ${CONCURRENT_COVER_LOADS}）...`);

            let loadedCount = 0;
            const totalCount = indicesToLoad.length;

            // 更新进度显示
            function updateProgress() {
                loadedCount++;
                updateCoverLoadStatus(`${loadedCount}/${totalCount}`, '');
            }

            // 单个封面加载函数
            async function loadSingleCover(index) {
                const track = state.playlist[index];
                if (!track || track.cover || track.coverLoading) return;

                track.coverLoading = true;

                try {
                    let blob;

                    // 检查是否已有完整缓存（播放过的歌曲）
                    if (track.url && track.url.startsWith('blob:')) {
                        // 从已缓存的URL获取Blob
                        console.log(`[${index}] 使用已缓存的数据提取封面`);
                        const cachedRes = await fetch(track.url);
                        blob = await cachedRes.blob();
                    } else {
                        // 使用Range请求只下载文件开头部分
                        const METADATA_SIZE = 1.5 * 1024 * 1024; // 1.5MB
                        const res = await fetch(track.fetchUrl, {
                            headers: {
                                'Authorization': track.auth,
                                'Range': `bytes=0-${METADATA_SIZE - 1}`
                            }
                        });
                        blob = await res.blob();
                        console.log(`[${index}] 下载了 ${(blob.size / 1024).toFixed(1)}KB`);
                    }

                    const meta = await getMetadata(blob);

                    if (meta.cover) {
                        track.cover = meta.cover;
                        track.title = meta.title || track.title;
                        track.artist = meta.artist || track.artist;

                        // 更新对应的列表项封面
                        const itemElement = elements.playlist.querySelector(`[data-index="${index}"]`);
                        if (itemElement) {
                            const coverContainer = itemElement.querySelector('.cover-container');
                            if (coverContainer) {
                                coverContainer.innerHTML = `<img src="${meta.cover}" class="w-full h-full object-cover">`;
                            }
                        }
                    }
                } catch (e) {
                    console.error(`加载封面失败 [${index}]:`, e);
                }

                track.coverLoading = false;
                updateProgress();
            }

            // 显示开始加载
            updateCoverLoadStatus(`0/${totalCount}`, '');

            // 并发控制：使用Promise池
            const pool = [];
            for (const index of indicesToLoad) {
                const promise = loadSingleCover(index).then(() => {
                    // 任务完成后从池中移除
                    pool.splice(pool.indexOf(promise), 1);
                });
                pool.push(promise);

                // 如果达到并发上限，等待任意一个完成
                if (pool.length >= CONCURRENT_COVER_LOADS) {
                    await Promise.race(pool);
                }
            }

            // 等待剩余任务完成
            await Promise.all(pool);
            console.log('封面加载完成');

            // 短暂显示完成状态后隐藏
            updateCoverLoadStatus('完成', '✓');
            setTimeout(() => {
                updateCoverLoadStatus('', '', false);
            }, 2000);
        }

        // 从图片提取主色调
        function extractColorsFromImage(imageSrc) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                try {
                    // 创建临时canvas来分析图片
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    const sampleSize = 50; // 缩小图片提高性能
                    tempCanvas.width = sampleSize;
                    tempCanvas.height = sampleSize;
                    tempCtx.drawImage(img, 0, 0, sampleSize, sampleSize);

                    const imageData = tempCtx.getImageData(0, 0, sampleSize, sampleSize).data;

                    // 收集颜色样本（只取图片下半部分，因为波形在下面）
                    const colorSamples = [];
                    const startY = Math.floor(sampleSize / 2);

                    for (let y = startY; y < sampleSize; y++) {
                        for (let x = 0; x < sampleSize; x++) {
                            const idx = (y * sampleSize + x) * 4;
                            const r = imageData[idx];
                            const g = imageData[idx + 1];
                            const b = imageData[idx + 2];
                            const a = imageData[idx + 3];

                            // 跳过透明和过亮/过暗的像素
                            if (a < 128) continue;
                            const brightness = (r + g + b) / 3;
                            if (brightness < 30 || brightness > 225) continue;

                            colorSamples.push({ r, g, b });
                        }
                    }

                    if (colorSamples.length === 0) return;

                    // 简单的颜色聚类 - 按色相分组
                    const colorGroups = {};
                    colorSamples.forEach(color => {
                        // 转HSL来获取色相
                        const max = Math.max(color.r, color.g, color.b);
                        const min = Math.min(color.r, color.g, color.b);
                        const l = (max + min) / 2 / 255;
                        let h = 0;
                        if (max !== min) {
                            const d = max - min;
                            if (max === color.r) h = ((color.g - color.b) / d + (color.g < color.b ? 6 : 0)) / 6;
                            else if (max === color.g) h = ((color.b - color.r) / d + 2) / 6;
                            else h = ((color.r - color.g) / d + 4) / 6;
                        }

                        // 按色相分组（12个分组）
                        const hueGroup = Math.floor(h * 12);
                        const key = `${hueGroup}-${Math.floor(l * 3)}`;

                        if (!colorGroups[key]) colorGroups[key] = { colors: [], count: 0 };
                        colorGroups[key].colors.push(color);
                        colorGroups[key].count++;
                    });

                    // 找到最常见的颜色组
                    let dominantGroup = null;
                    let maxCount = 0;
                    Object.values(colorGroups).forEach(group => {
                        if (group.count > maxCount) {
                            maxCount = group.count;
                            dominantGroup = group;
                        }
                    });

                    if (!dominantGroup) return;

                    // 计算主色组的平均色
                    const avgColor = { r: 0, g: 0, b: 0 };
                    dominantGroup.colors.forEach(c => {
                        avgColor.r += c.r;
                        avgColor.g += c.g;
                        avgColor.b += c.b;
                    });
                    avgColor.r = Math.round(avgColor.r / dominantGroup.colors.length);
                    avgColor.g = Math.round(avgColor.g / dominantGroup.colors.length);
                    avgColor.b = Math.round(avgColor.b / dominantGroup.colors.length);

                    // 生成配套颜色
                    state.visualizerColors = {
                        primary: avgColor,
                        secondary: {
                            r: Math.max(0, avgColor.r - 40),
                            g: Math.max(0, avgColor.g - 40),
                            b: Math.max(0, avgColor.b - 40)
                        },
                        accent: {
                            r: Math.min(255, avgColor.r + 30),
                            g: Math.min(255, avgColor.g + 30),
                            b: Math.min(255, avgColor.b + 30)
                        }
                    };

                    console.log('提取的主色调:', state.visualizerColors);
                } catch (e) {
                    console.error('颜色提取失败:', e);
                }
            };
            img.src = imageSrc;
        }

        function setupVisualizer() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                state.source = state.audioContext.createMediaElementSource(elements.audio);
                state.source.connect(state.analyser);
                state.analyser.connect(state.audioContext.destination);
                state.analyser.fftSize = 256; // 更高精度
            }
            if (state.animationId) cancelAnimationFrame(state.animationId);

            const canvas = elements.visualizer;
            const ctx = canvas.getContext('2d');
            const bufferLength = state.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            // 平滑过渡数据
            const smoothedData = new Float32Array(bufferLength);
            const smoothingFactor = 0.7;

            function draw() {
                state.animationId = requestAnimationFrame(draw);
                state.analyser.getByteFrequencyData(dataArray);

                // 确保canvas尺寸正确
                if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }

                const width = canvas.width;
                const height = canvas.height;

                // 获取当前颜色
                const colors = state.visualizerColors;
                const { primary, secondary, accent } = colors;

                // 清除画布
                ctx.clearRect(0, 0, width, height);

                // 只取前64个频段（低频和中频更有视觉效果）
                const barsCount = 64;
                const barWidth = width / barsCount;
                const gap = 2;

                for (let i = 0; i < barsCount; i++) {
                    // 平滑过渡
                    smoothedData[i] = smoothedData[i] * smoothingFactor + dataArray[i] * (1 - smoothingFactor);

                    const barHeight = (smoothedData[i] / 255) * height * 0.85;
                    const x = i * barWidth;
                    const y = height - barHeight;

                    // 创建渐变色 - 使用从封面提取的颜色
                    const gradient = ctx.createLinearGradient(x, height, x, y);
                    const intensity = smoothedData[i] / 255;

                    // 根据音频强度动态调整颜色透明度
                    gradient.addColorStop(0, `rgba(${primary.r}, ${primary.g}, ${primary.b}, ${0.1 + intensity * 0.3})`); // 底部淡
                    gradient.addColorStop(0.5, `rgba(${primary.r}, ${primary.g}, ${primary.b}, ${0.3 + intensity * 0.4})`); // 中间
                    gradient.addColorStop(1, `rgba(${secondary.r}, ${secondary.g}, ${secondary.b}, ${0.5 + intensity * 0.5})`); // 顶部浓

                    // 绘制圆角柱子
                    const radius = Math.min(barWidth - gap, barHeight) / 2;
                    ctx.beginPath();
                    if (barHeight > radius * 2) {
                        ctx.moveTo(x + gap / 2 + radius, y);
                        ctx.lineTo(x + barWidth - gap / 2 - radius, y);
                        ctx.quadraticCurveTo(x + barWidth - gap / 2, y, x + barWidth - gap / 2, y + radius);
                        ctx.lineTo(x + barWidth - gap / 2, height);
                        ctx.lineTo(x + gap / 2, height);
                        ctx.lineTo(x + gap / 2, y + radius);
                        ctx.quadraticCurveTo(x + gap / 2, y, x + gap / 2 + radius, y);
                    } else {
                        ctx.roundRect(x + gap / 2, y, barWidth - gap, barHeight, radius);
                    }
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // 添加微弱的发光效果 - 使用主颜色
                    if (intensity > 0.5) {
                        ctx.shadowColor = `rgba(${accent.r}, ${accent.g}, ${accent.b}, 0.6)`;
                        ctx.shadowBlur = 12 * intensity;
                    }
                }

                // 重置阴影
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // 添加底部渐变遮罩（让波形底部融入背景）
                const fadeGradient = ctx.createLinearGradient(0, height * 0.7, 0, height);
                fadeGradient.addColorStop(0, 'rgba(235, 229, 223, 0)');
                fadeGradient.addColorStop(1, 'rgba(235, 229, 223, 0.8)');
                ctx.fillStyle = fadeGradient;
                ctx.fillRect(0, height * 0.7, width, height * 0.3);
            }
            draw();
        }

        elements.fileInput.onchange = async (e) => {
            elements.loadingStatus.classList.remove('hidden');
            for (let file of e.target.files) {
                const meta = await getMetadata(file);
                state.playlist.push({ name: file.name, url: URL.createObjectURL(file), source: 'local', ...meta });
            }
            renderPlaylist();
            elements.loadingStatus.classList.add('hidden');
        };

        elements.audio.ontimeupdate = () => {
            elements.progressBar.value = (elements.audio.currentTime / elements.audio.duration) * 100 || 0;
            const m = Math.floor(elements.audio.currentTime / 60), s = Math.floor(elements.audio.currentTime % 60);
            elements.currentTimeText.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };
        elements.audio.onloadedmetadata = () => {
            const m = Math.floor(elements.audio.duration / 60), s = Math.floor(elements.audio.duration % 60);
            elements.durationTimeText.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };
        elements.progressBar.oninput = (e) => elements.audio.currentTime = (e.target.value / 100) * elements.audio.duration;
        elements.volumeBar.oninput = (e) => elements.audio.volume = e.target.value / 100;

        elements.clearBtn.onclick = () => {
            state.playlist = []; state.currentIndex = -1; state.isPlaying = false;
            elements.audio.src = ''; elements.coverImg.classList.remove('opacity-100');
            elements.defaultCover.classList.remove('opacity-0');
            renderPlaylist(); updatePlayIcon();
        };

        window.onresize = () => {
            if (elements.visualizer.parentElement) {
                elements.visualizer.width = elements.visualizer.parentElement.clientWidth;
                elements.visualizer.height = 128;
            }
        };
        window.onresize();

        // ========== 播放状态持久化 ==========
        const STORAGE_KEY = 'musicPlayerState';

        function saveState() {
            try {
                // 只保存本地文件的播放列表（WebDAV需要重新连接）
                const localTracks = state.playlist.filter(t => t.source !== 'webdav').map(t => ({
                    name: t.name,
                    title: t.title,
                    artist: t.artist,
                    cover: t.cover,
                    source: t.source
                    // 不保存blob URL，因为刷新后失效
                }));

                const saveData = {
                    playMode: state.playMode,
                    volume: elements.audio.volume,
                    currentTrackName: state.playlist[state.currentIndex]?.name || null,
                    // 注意：本地文件的URL刷新后失效，只保存元数据用于显示
                    localTracksCount: localTracks.length
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.error('保存状态失败:', e);
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return;

                const data = JSON.parse(saved);

                // 恢复播放模式
                if (data.playMode) {
                    state.playMode = data.playMode;
                    updateModeButton();
                }

                // 恢复音量
                if (data.volume !== undefined) {
                    elements.audio.volume = data.volume;
                    elements.volumeSlider.value = data.volume * 100;
                }

                console.log('已恢复播放设置');
            } catch (e) {
                console.error('加载状态失败:', e);
            }
        }

        // 更新模式按钮显示
        function updateModeButton() {
            const modes = [
                { mode: 'list', icon: 'repeat', title: '列表循环' },
                { mode: 'random', icon: 'shuffle', title: '随机播放' },
                { mode: 'single', icon: 'repeat-1', title: '单曲循环' }
            ];
            const current = modes.find(m => m.mode === state.playMode);
            if (current && elements.modeBtn) {
                const iconContainer = elements.modeBtn;
                const currentIcon = iconContainer.querySelector('svg') || iconContainer.querySelector('[data-lucide]');
                if (currentIcon) {
                    currentIcon.outerHTML = `<i data-lucide="${current.icon}" id="modeIcon" class="w-5 h-5"></i>`;
                }
                lucide.createIcons({ nodes: [iconContainer] });
                elements.modeIcon = iconContainer.querySelector('svg');
                elements.modeBtn.title = current.title;
            }
        }

        // 页面加载时恢复状态
        loadState();

        // 监听状态变化自动保存
        elements.audio.addEventListener('volumechange', saveState);
        elements.modeBtn.addEventListener('click', () => setTimeout(saveState, 100));

        // ========== 键盘快捷键 ==========
        document.addEventListener('keydown', (e) => {
            // 忽略输入框中的按键
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    elements.playBtn.click();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevTrack();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextTrack();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    elements.audio.volume = Math.min(1, elements.audio.volume + 0.1);
                    elements.volumeSlider.value = elements.audio.volume * 100;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    elements.audio.volume = Math.max(0, elements.audio.volume - 0.1);
                    elements.volumeSlider.value = elements.audio.volume * 100;
                    break;
                case 'KeyM':
                    // M键静音/取消静音
                    elements.audio.muted = !elements.audio.muted;
                    break;
            }
        });

        // ========== 深色模式 ==========
        const themeToggle = document.getElementById('themeToggle');
        const themeIconSun = document.getElementById('themeIconSun');
        const themeIconMoon = document.getElementById('themeIconMoon');

        function updateThemeIcons(isDark) {
            if (isDark) {
                themeIconSun.classList.remove('hidden');
                themeIconMoon.classList.add('hidden');
            } else {
                themeIconSun.classList.add('hidden');
                themeIconMoon.classList.remove('hidden');
            }
            // 更新meta theme-color
            const themeColor = isDark ? '#1a1a1a' : '#d4a373';
            document.querySelector('meta[name="theme-color"]').setAttribute('content', themeColor);
        }

        function toggleTheme() {
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcons(isDark);
        }

        // 初始化主题
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.classList.add('dark');
                updateThemeIcons(true);
            }

            // 渲染图标
            lucide.createIcons({ nodes: [themeToggle] });
        }

        themeToggle.addEventListener('click', () => {
            toggleTheme();
            lucide.createIcons({ nodes: [themeToggle] });
        });

        initTheme();
    </script>
</body>

</html>
